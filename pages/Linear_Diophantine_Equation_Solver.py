import streamlit as st
import numpy as np
import pandas as pd
from math import floor, ceil
import plotly.express as px
from pages.Extended_Euclidean_Algorithm import get_mimimal_linear_combination, get_linear_combination

def example_solution_formula(i,j):
    k = -34 - i
    return np.where(j == 0, 200 + 5*k, -100 - 3*k)

st.title('Linear Diophantine Equation Solver')
st.markdown(
    """
    **Linear Diophantine Equations** have two or more unknown values, and are of the form
    """
            )
st.latex("AX + BY = C")

st.write("where A, B, and C are integers.")

col1, col2, col3 = st.columns(3)

A_init = col1.number_input("A",step=1)
B_init = col2.number_input("B",step=1)
C_init = col3.number_input("C",step=1)
G = np.gcd(A_init,B_init)

# the equation is only solvable if C is divisible by the GCD of A and B
if ( not G or C_init/G != int(C_init/G) or A_init == 0 or B_init == 0):
    if (A_init == 0 or B_init == 0):
        st.write("You can figure that one out :wink:")
    else:
        st.write("The equation only has integer solutions if C is divisible by the GCD of A and B.")
else:
    # sanity checks
    correct_result_dict = {}

    A = int(A_init / G)
    B = int(B_init / G)
    C = int(C_init / G)
    initial_solution = get_linear_combination(A, B, C)
    # solution is trivial
    if (abs(A) == 1 or abs(B) == 1):
        # just loop over the larger of AX and BY and solve for the opposite variable
        if (abs(A) == 1):
            solution_rows = abs(int(C/B)) if C/B > int(C/B) else abs(int(C/B) -1)
            solution_cols = 2
            solutions = np.fromfunction(lambda i,j: np.where(j == 0, A*(C - B*(i+1)), (i+1)), (solution_rows,solution_cols),dtype=int)
        if (abs(B) == 1):
            solution_rows = abs(int(C/B)) if C/B > int(C/B) else abs(int(C/B) -1)
            solution_cols = 2
            solutions = np.fromfunction(lambda i,j: np.where(j == 0, (i+1), B*(C - (i+1) * A)), (solution_rows,solution_cols),dtype=int)
        # negatives are involved, so there's no need for just positive solutions
    else:
        # solution is nontrivial
        st.subheader("Initial Solution")
        st.write(C_init, " = ", A_init, "(", initial_solution[2], ") + ", B_init, "(", initial_solution[4], ").")
        st.write(C, " = ", A, "(", initial_solution[2], ") + ", B, "(", initial_solution[4], ").")
        X_init = initial_solution[2]
        Y_init = initial_solution[4]
        st.write("**All integer solutions** are generated by")
        # X_k = X_0 + Bk
        # Y_k = Y_0 - Ak
        st.latex(f"X_k = {X_init} + {B}k")
        st.latex(f"Y_k = {Y_init} - {A}k")
        st.write("for any integer k.")

        # positive solutions to positive equations
        if (A > 0 and B > 0 and C > 0):
            k_upper_bound = ceil(Y_init / A)
            k_lower_bound = floor(-X_init / B)
            solution_rows = k_upper_bound -1 - k_lower_bound
            st.write(" All ", solution_rows, " nonnegative solutions are generated by")
            st.latex(f"{k_lower_bound} \lt k \lt {k_upper_bound}") 
        else:
            k_upper_bound = ceil(Y_init / A) + 5
            k_lower_bound = ceil(Y_init / A) - 5
            solution_rows = k_upper_bound -1 - k_lower_bound
            st.write("Here are 10 of them")
        solution_cols = 2
        if solution_rows > 0:
            # generate solutions within upper and lower bounds of k
            solutions = np.fromfunction(lambda i, j: np.where(j == 0,  
                                                            (X_init + B*(k_upper_bound -1 -i)),
                                                            (Y_init - A*(k_upper_bound -1 -i))), 
                                                        (solution_rows,solution_cols), dtype=int)
            # test cases
            # check upper and lower bounds
            correct_result_dict.update({"Correct Upper Bound": X_init + B*(k_upper_bound) <= 0 or Y_init - A*(k_upper_bound) <= 0})
            correct_result_dict.update({"Correct Lower Bound": X_init + B*(k_lower_bound) <= 0 or Y_init - A*(k_lower_bound) <= 0})

    #all elements must be positive
    if ('solutions' in locals()):
        if np.any(solutions <= 0):
            correct_result_dict.update({"Positive Solutions": False})
        #all solution pairs must solve the equation
        for i in range(0, len(solutions)):
            correct_result_dict.update({f"Solution {i+1} Validity": A_init * solutions[i][0] + B_init * solutions[i][1]}) #  == C_init
        correct_result_arr = np.array(correct_result_dict.values())
        correct_result = np.all(correct_result_arr == True)
    
            
        #st.write("sanity check: ", correct_result)
        #st.write(correct_result_dict)
        # table of solutions
        st.markdown("""### Table of Solutions (Positive When Possible)""")
        df = pd.DataFrame(solutions, columns=["X","Y"])
        st.dataframe(df, hide_index=True, use_container_width=True)
        st.scatter_chart(df, x="X", y="Y")
    else: 
        st.write("There are no positive solutions to display.")
        

###############################################################################
# Example
###############################################################################

st.markdown(
    """
    ## Real-Life Example
    I'm training a machine learning model using two types of GPUs:

    ¯\\\_(ツ)\_/¯ Basic GPUs process 3 training batches per hour.

    ¯\\\_(ツ)\_/¯ Advanced GPUs process 5 training batches per hour.

    The goal is to train 100 batches in a single hour.  How many of each should I use?


    ### Solution
    Let X be the number of basic GPUs and Y be the number of advanced GPUs.  Then the equation we need to solve is
    """
            )
st.latex("3X + 5Y = 100.")




st.markdown(
    """
    We will begin by solving the related equation, 3X + 5Y = 1, using the [Extended Euclidean Algorithm](./Extended_Euclidean_Algorithm).
    """
            )
min = get_mimimal_linear_combination(3,5)
st.write(min[0], " = ", min[1], "(", min[2], ") + ", min[3], "(", min[4], ").")

st.markdown(
    """
    Next we multiply both sides of the equation by 100 to find
    """
)
impossible_solution = get_linear_combination(3,5,100)
st.write(impossible_solution[0], " = ", impossible_solution[1], "(", impossible_solution[2],
          ") + ", impossible_solution[3], "(", impossible_solution[4], ").")

st.markdown(
    """
    But this won't work, because we can't have a negative number of GPUs.  Luckily, these equations
    have infinitely many integer solutions, generated by the following equations:
    """
)

st.latex("X_k = X_0 + Bk")
st.latex("Y_k = Y_0 - Ak")

st.markdown(
    """
    for any integer k.  So in our case, we have
    """
)
st.latex("X_k = 200 + 5k")
st.latex("Y_k = -100 - 3k.")

st.markdown(
    """
    This is easily verified by induction.  Setting both solution equations to be greater than zero and solving for 
    k gives us the full set of possible solutions, generated by 
    """
)

st.latex("-40 \lt k \lt -33")

rows = 39 - 33
cols = 2
example_solutions = np.fromfunction(lambda i, j: np.where(j == 0, 200 + 5*(-34-i), -100 - 3*(-34-i)), 
                                                  (rows,cols), dtype=int)

st.markdown("""### Table of All Possible Solutions""")
df = pd.DataFrame(example_solutions, columns=["X (Basic GPUs)","Y (Advanced GPUs)"])
st.dataframe(df, hide_index=True, use_container_width=True)




st.markdown(
    """
    Now I can just pick whatever balance of GPUs based on whatever outside factor I like, like cost.
    An equation like this is easy to solve in a field like **R** or **Q**, because every value of X has a 
    corresponding value of Y.  But in the ring of integers, it's not so simple.  Often in real life
    we need integer solutions to such equations, and since I was recently teaching AI models how to 
    solve this kind of equation, I figured I'd write a program to automate parts of the task.  
    """
            )

